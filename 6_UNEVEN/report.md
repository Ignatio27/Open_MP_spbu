# **ОТЧЁТ ПО ЭКСПЕРИМЕНТУ (режимы `schedule` в OpenMP)**

## **Описание эксперимента**

В работе исследуется влияние различных режимов распределения итераций цикла `for` на производительность OpenMP‑программы с заведомо неравномерной нагрузкой на итерациях. Рассматриваются три варианта планирования: `schedule(static)`, `schedule(dynamic)` и `schedule(guided)`.

Цикл сконструирован так, что большая часть итераций остаётся относительно «лёгкой», а меньшая часть выполняет существенно больше арифметических операций, создавая неравномерность по времени выполнения. Для оценки масштабируемости выбраны два размера задачи: \(N = 5 \cdot 10^{5}\) и \(N = 5 \cdot 10^{6}\); для каждого из них измеряются время выполнения и ускорение относительно последовательного варианта.

## **Реализация цикла и параллельных версий**

Нагрузка на итерацию задаётся числом внутренних повторений, которое резко возрастает после некоторого индекса \(i_{\text{heavy}}\):

\[
\text{reps}(i) =
\begin{cases}
r_{\text{light}}(i), & i < i_{\text{heavy}},\\
r_{\text{heavy}}, & i \ge i_{\text{heavy}}.
\end{cases}
\]

Последовательный вариант цикла:

for (long long i = 0; i < N; ++i) {
int reps = (i < heavy_start ? light_reps(i) : heavy_reps);
double x = 0.0;
for (int k = 0; k < reps; ++k) {
x = x * 1.0000001 + 1.0;
}
acc += x;
}

Параллельная версия использует редукцию по сумме и выбор режима планирования через `omp_set_schedule`:

omp_set_schedule(policy, chunk_size);

#pragma omp parallel for schedule(runtime) reduction(+ : acc)
for (long long i = 0; i < N; ++i) {
int reps = (i < heavy_start ? light_reps(i) : heavy_reps);
double x = 0.0;
for (int k = 0; k < reps; ++k) {
x = x * 1.0000001 + 1.0;
}
acc += x;
}


Таким образом, при **static** диапазон индексов заранее делится на непрерывные блоки между потоками; при **dynamic** нити получают новые порции работы по мере освобождения; при **guided** размер блоков по ходу выполнения уменьшается, что снижает накладные расходы по сравнению с чисто динамическим вариантом.

---

## **Результаты для N = \(5 \cdot 10^{5}\)**

### Графики

- Ускорение: `uneven_N500000_speedup_by_schedule.jpg`.
- Время выполнения: `uneven_N500000_time_by_schedule.jpg`.

### Наблюдения

- На всём диапазоне от 1 до 10 потоков режимы `static`, `dynamic` и `guided` дают практически совпадающие значения ускорения, которое растёт почти линейно до 8–10 потоков и достигает порядка \(S \approx 7\text{–}7.5\).
- Времена исполнения для трёх режимов различаются минимально: от ~0.9 с на одном потоке до ~0.12 с на 8–10 потоках, что говорит об отсутствии заметного дисбаланса.

### Объяснение

Объём вычислений при \(N = 5 \cdot 10^{5}\) относительно невелик, а доля тяжёлых итераций мала, поэтому даже неидеальное распределение этих итераций не приводит к серьёзному перекосу нагрузки.Накладные расходы на динамическое назначение работы сопоставимы с потенциальным выигрышем, из‑за чего профили `dynamic` и `guided` практически не отличаются от `static`.

---

## **Результаты для N = \(5 \cdot 10^{6}\)**

### Графики

- Ускорение: `uneven_N5000000_speedup_by_schedule.jpg`.
- Время выполнения: `uneven_N5000000_time_by_schedule.jpg`.
### Наблюдения

- Время работы на одном потоке составляет около 8.8–9 с; при увеличении числа потоков до 8–10 оно уменьшается до ~1.2–1.3 с для всех трёх вариантов планирования.
- Ускорение достигает значений \(S \approx 7\text{–}7.3\), при этом кривые `static`, `dynamic` и `guided` практически совпадают, различаясь лишь на несколько процентов.

### Объяснение

Даже при десятикратном увеличении размера задачи структура цикла остаётся той же, а тяжёлый участок не приходится полностью на интервал, который целиком обрабатывает один поток при статическом расписании. В результате ни один режим `schedule` не даёт выраженного преимущества, а масштабируемость ограничивается в основном памятью и накладными расходами OpenMP.

---

## **Итоговые выводы**

1. Для выбранного примера неравномерного цикла все три режима `schedule(static)`, `schedule(dynamic)` и `schedule(guided)` демонстрируют **очень близкую производительность** на диапазоне от 1 до 10 потоков.
2. При обоих размерах задачи достигается ускорение порядка \(S \approx 7\text{–}7.5\), что указывает на хорошую масштабируемость ядра и отсутствие сильного дисбаланса по нагрузке между потоками.
3. В рассматриваемой конфигурации накладные расходы динамического и направляемого планирования не компенсируются выигрышем по времени, поэтому режим `static` остаётся вполне конкурентным, а переход к `dynamic` или `guided` имеет смысл только при более выраженной неравномерности вычислительной нагрузки.
